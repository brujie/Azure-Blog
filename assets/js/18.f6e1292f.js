(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{425:function(n,e,t){"use strict";t.r(e);var s=t(31),a=Object(s.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"力扣算法初级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#力扣算法初级"}},[n._v("#")]),n._v(" 力扣算法初级")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("数组去重\n\n")])])]),t("p",[n._v("代码：\nlet nums = [1,1,2];\nlet removeDuplicates = function(nums) {\nlet tempArr = [];\nfor(let i=0;i<nums.length;i++){\nlet flag = tempArr.indexOf(nums[i]);\nif(flag == -1){\ntempArr.push(nums[i]);\n}\n}\nreturn tempArr;\n};\nremoveDuplicates(nums);")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\n\n旋转数组\n给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。\n")])])]),t("p",[n._v("示例 1:")]),n._v(" "),t("p",[n._v("输入: nums = [1,2,3,4,5,6,7], k = 3\n输出: [5,6,7,1,2,3,4]\n解释:\n向右轮转 1 步: [7,1,2,3,4,5,6]\n向右轮转 2 步: [6,7,1,2,3,4,5]\n向右轮转 3 步: [5,6,7,1,2,3,4]\n示例 2:")]),n._v(" "),t("p",[n._v("输入：nums = [-1,-100,3,99], k = 2\n输出：[3,99,-1,-100]\n解释:\n向右轮转 1 步: [99,-1,-100,3]\n向右轮转 2 步: [3,99,-1,-100]")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code")])]),t("p",[n._v("代码:\nlet  nums = [1,2,3,4,5,6,7]\nlet rotate = function(nums, k) {\nif(nums.length == k){l\nnums.reverse();\n}\nlet temp = Object.assign([], nums);    // 获取之后的数据\ntemp = temp.slice(-k);\nnums.length = nums.length - k;\nreturn [...temp,...nums];\n};\nrotate(nums,3)")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("存在重复元素\n")])])]),t("p",[n._v("给定一个整数数组，判断是否存在重复元素。")]),n._v(" "),t("p",[n._v("如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。")]),n._v(" "),t("p"),n._v(" "),t("p",[n._v("示例 1:")]),n._v(" "),t("p",[n._v("输入: [1,2,3,1]\n输出: true\n示例 2:")]),n._v(" "),t("p",[n._v("输入: [1,2,3,4]\n输出: false\n示例 3:")]),n._v(" "),t("p",[n._v("输入: [1,1,1,3,3,4,3,2,4,2]\n输出: true")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code")])]),t("p",[n._v("代码：\nlet arr = [1,1,1,3,3,4,3,2,4,2];\nlet containsDuplicate = function(nums) {\nfor(let i = 0; i < nums.length - 1; i++) {\nif (nums[i] == nums[i + 1]) {\nreturn true;\n}\n}\nreturn false;\n}\ncontainsDuplicate(arr)")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\n只出现一次的数字\n给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n说明：\n\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n示例 1:\n\n输入: [2,2,1]\n输出: 1\n示例 2:\n\n输入: [4,1,2,1,2]\n输出: 4\n\n")])])]),t("p",[n._v("let arr =  [4,1,2,1,2];")]),n._v(" "),t("p",[n._v("var singleNumber = function(arr,k) {\nlet tempArr = [];\nfor(let i=0;i<arr.length;i++){\nif(arr[i] == k){\ntempArr.push(arr[i]);\n}\n}\nif(tempArr.length == 1){\nreturn tempArr[0];\n} else {\nreturn false;\n}\n};\nsingleNumber(arr,4)")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code")])])])}),[],!1,null,null,null);e.default=a.exports}}]);